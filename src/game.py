# -*- coding: utf-8 -*-

from math import floor
from random import shuffle
# from scheduler import Scheduler
import time


global_speeds        = [1, 8 , 6  , 5  , 4  , 3  , 2.5, 2  ]
global_uses          = [2, 2 , 2  , 2  , 3  , 4  , 4  , 100]
global_probabilities = [0, .5, 5/8, 6/8, 6/8, 7/8, 7/8, 7/8]


class Game:
    def __init__(self, nb_scenes, player, scheduler):
        """ Define the initial state of the game.
        The player is on the middle of the scene 0 where nb_scenes scenes are created.
        To allow the possibility of multiple walls on a screen NB_CACHE walls are generated by advance.
        """
        self.nb_scenes = nb_scenes
        self.scenes = [False] * nb_scenes
        self.player = player
        self.colided = False

        self.difficulty = 0
        self.start_time = 0
        self.stop_time = 0
        self.scheduler = scheduler
        self.event_idx = 0


        self.difficulty_parameters = []
        for idx, nb_uses in enumerate(global_uses):
            for _ in range(nb_uses):
                self.difficulty_parameters.append({
                    "speed":global_speeds[idx],
                    "proba":global_probabilities[idx]
                })


    # ----------- Maze functions -----------

    def create_walls(self, filling_ratio):
        """ Create a new layer of wall in the scene cache.
        The parameter filling_ratio will decide the number of walls generated
        with a minimum of 1 wall and maximum of nb_scenes-1.
        """
        # Get the number of walls
        nb_walls = floor(filling_ratio * self.nb_scenes)
        if nb_walls >= self.nb_scenes:
            nb_walls = self.nb_scenes - 1
        elif nb_walls < 0:
            nb_walls = 1

        # Generate the list
        new_walls = [True] * nb_walls + [False] * (self.nb_scenes - nb_walls)
        shuffle(new_walls)

        # Add the new walls
        self.scenes = new_walls

    # ----------- Player functions -----------

    def collide(self):
        """ Test if the player is on a scene where a wall if present.
        """
        position = self.player.get_ratio_position()
        screen = floor(position * self.nb_scenes)
        return self.scenes[screen]

    # ------------ Time functions ------------

    def start(self):
        """ Start the game scheduler
        """
        self.colided = False

        self.start_time = time.time()
        self.difficulty = 0
        self.update_game_state()


    def update_game_state(self, idx=0, walls=[], speed=1):
        # Test for wall collision
        if self.collide():
            self.stop()
            self.colided = True
            return

        # Get difficulty state in the game
        params = self.difficulty_parameters[self.difficulty]
        self.difficulty += 1
        filling_ratio = params["proba"]
        speed = params["speed"]

        # Create new walls
        self.create_walls(filling_ratio)

        # Add the walls to the event scheduler
        self.scheduler.enter(speed, 1, self.update_game_state, kwargs={
            "idx": self.event_idx,
            "walls": self.scenes[::],
            "speed": speed
        })
        self.event_idx += 1


    def stop(self):
        """ Stop the game and save the current time
        """
        self.stop_time = time.time()
        # Cancel remaining events
        events = list(self.scheduler.queue)
        for e in events:
            self.scheduler.cancel(e)





